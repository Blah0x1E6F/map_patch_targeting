<!DOCTYPE html>
<html>
<head>
  <title>Map Prototype</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      display: flex;
      flex-direction: column;
    }
    #map {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
    }
    #header, #footer {
      background-color: lightgray;
      padding: 10px;
      text-align: center;
    }
    .content {
      background-color: lightblue;
      flex-grow: 1;
      padding: 10px;
    }
  </style>
  <!-- LOAD our MapBox api key. I'm going to .gitignore that file, so the secret is not
   stored to github. This file should contain the line
      var mapBoxToken = '<REPLACE WITH MY MAPBOX TOKEN>' -->
  <script src="secret_do_not_upload_to_github.js"></script>
</head>
<body>
  <div id="header">
    <form id="mapForm">
        <input type="number" id="lat" placeholder="Latitude" step="any" required>
        <input type="number" id="lon" placeholder="Longitude" step="any" required>
        <input type="number" id="radius" placeholder="Radius (m)" required>
        <button type="submit">Update Map</button>
    </form>
  </div>
  <div id="map"></div>
  <div id="footer">
    <p>Hello, this is my footer<br />Blah blah</p>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    "use strict";

    var defLat = 41.010418;
    var defLon = -73.920776;
    var defRadius = 500; // in meters
    var fracOfDegree = 0.001;
    const WEIGHT = 2;
    
    var map = L.map('map').setView([defLat, defLon], 16);
    L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=' + mapBoxToken, {
      maxZoom: 18,
      id: 'mapbox/streets-v11', // You can use other styles like 'mapbox/satellite-v9'
      tileSize: 512,
      zoomOffset: -1,
      accessToken: mapBoxToken
    }).addTo(map);

    function drawCircle(lat, lon, radius) {
      var circle = L.circle([lat, lon], {
        color: 'red',
        fillOpacity: 0.1,
        radius: radius,
        weight: WEIGHT,
      });
      circle.addTo(map);
      return circle;
    }

    // I use "segment" to refer to the shape defined by lower-left corner and N deg east & N deg north.
    // Technically it's not a square; not sure what this shape is called in cartography.
    function drawSegment(lat, lon, degreesPerSide) {
      var lowerLeft = [lat, lon];
      var lowerRight = [lat, lon + degreesPerSide]; 
      var upperRight = [lat + degreesPerSide, lon + degreesPerSide];
      var upperLeft = [lat + degreesPerSide, lon];
      var segment = L.polygon([lowerLeft, lowerRight, upperRight, upperLeft, lowerLeft], {
        color: 'green',
        fillOpacity: 0.1,
        weight: 1,
      }).addTo(map);
      return segment;
    }

    // Example rounding PI to nearest 0.0001: 3.1415
    // Example rounding PI to nearest 0.05: 3.1
    function roundDownToNearestFractionOfDegree(numberToRoundDown, fractionOfDegree) {
      return Math.floor(numberToRoundDown/fractionOfDegree) * fractionOfDegree;
    }

    function isOverlap(circle, sw, se, ne, nw) {
      var center = circle.getLatLng();
      var radius = circle.getRadius();
      if (center.distanceTo(sw) <= radius 
        || center.distanceTo(se) <= radius
        || center.distanceTo(ne) <= radius
        || center.distanceTo(nw) <= radius
      ) {
        return true;
      } else {
        return false;
      }
    }

    // Form submission event listener
    // document.getElementById('mapForm').addEventListener('submit', function(event) {
    //   event.preventDefault();

    //   var lat = parseFloat(document.getElementById('lat').value);
    //   var lon = parseFloat(document.getElementById('lon').value);
    //   var radius = parseFloat(document.getElementById('radius').value);

    //   // Clear existing layers
    //   map.eachLayer(function(layer) {
    //     if (!layer._url) { // Don't remove the tile layer
    //       map.removeLayer(layer);
    //     }
    //   });

    //   var circle = drawCircle(latitude, longitude, radius);
    //   drawSegment(latitude, longitude, fracOfDegree);

    //   // Draw the bounding square with dashed border
    //   var boundingSquare = L.rectangle(circle.getBounds(), {
    //       color: 'red',
    //       fillOpacity: 0,
    //       dashArray: '5, 5',
    //       weight: WEIGHT,
    //   });
    //   boundingSquare.addTo(map);

    //   // Recenter the map on the new coordinates
    //   map.setView([latitude, longitude], 16);
    // });
    
    var circle = drawCircle(defLat, defLon, defRadius);
    var marker = L.marker([defLat, defLon]).addTo(map);
    L.rectangle(circle.getBounds(), {
      color: 'red',
      fillOpacity: 0,
      dashArray: '5, 10',
      weight: WEIGHT,
    }).addTo(map);
    
    // Get the lon (west) and lat (south) that's the nearest fracOfDegree left of and below the bounding square
    var south = circle.getBounds().getSouth();
    var southAdj = roundDownToNearestFractionOfDegree(south, fracOfDegree);

    // Draw tiles that overlap the circle's bounding square
    while (southAdj < circle.getBounds().getNorth()) {
      var west = circle.getBounds().getWest();
      var westAdj = roundDownToNearestFractionOfDegree(west, fracOfDegree);
      while (westAdj < circle.getBounds().getEast()) {
        var sw = L.latLng(southAdj, westAdj);
        var se = L.latLng(southAdj, westAdj + fracOfDegree);
        var ne = L.latLng(southAdj + fracOfDegree, westAdj + fracOfDegree);
        var nw = L.latLng(southAdj + fracOfDegree, westAdj);
        if (isOverlap(circle, sw, se, ne, nw)) {
          drawSegment(southAdj, westAdj, fracOfDegree);
        }
        westAdj += fracOfDegree;
      }
      southAdj += fracOfDegree;
    }
  </script>
</body>
</html>
